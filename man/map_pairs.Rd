% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/map-pairs.R
\name{map_pairs}
\alias{every_pair}
\alias{map_pairs}
\alias{probe_pairs}
\alias{some_pairs}
\title{Apply a binary function to pairs of list elements}
\usage{
map_pairs(.x, .f, ..., .filter = `>=`)

probe_pairs(.x, .p, ..., .filter = `>=`)

every_pair(.x, .p, ..., .filter = `>=`)

some_pairs(.x, .p, ..., .filter = `>=`)
}
\arguments{
\item{.x}{A list or vector.}

\item{.f}{A function of at least two arguments.}

\item{...}{Additional arguments passed on to \code{.f} or \code{.p}.}

\item{.filter}{A predicate function passed on to \code{cross_n()}
to filter out unwanted combinations of the elements of
\code{.x}. When \code{NULL}, all combinations are kept.}

\item{.p}{A predicate function of at least two arguments.}
}
\value{
A list for \code{map_pairs()}, a logical vector for
\code{probe_pairs()}, \code{TRUE} or \code{FALSE} for
\code{every_pairs()} and \code{some_pairs()}.
}
\description{
Apply a binary function to pairs of the elements of \code{.x}. The
pairs are generated with \code{\link{cross_n}()} and can be
filtered using the \code{.filter} argument. The default filter
leaves only unique combinations. The elements of the combinations
are recorded for each element of the returned list in the
\code{parent} attribute.
}
\details{
\code{probe_pairs()} is similar but applies a predicate function
\code{.p} and returns a logical vector. \code{every_pair()} checks
that a predicate function returns \code{TRUE} on all
pairs. \code{some_pairs()} checks that at least one pair returns
\code{TRUE}.
}
\examples{
l <- as.list(1:5)
map_pairs(l, sum) \%>\% str()
probe_pairs(l, `==`, .filter = NULL) \%>\% str()
}
\seealso{
\code{\link{map_neighbours}()} and
\code{\link{probe_neighbours}()}.
}

