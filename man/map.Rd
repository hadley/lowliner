% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/map.R
\name{map}
\alias{map}
\alias{map_if}
\alias{map_at}
\alias{map_lgl}
\alias{map_chr}
\alias{map_int}
\alias{map_dbl}
\alias{map_raw}
\alias{map_vec}
\alias{map_dfr}
\alias{map_df}
\alias{map_dfc}
\alias{walk}
\alias{map_depth}
\title{Apply a function to each element of a vector}
\usage{
map(.x, .f, ...)

map_if(.x, .p, .f, ..., .else = NULL)

map_at(.x, .at, .f, ...)

map_lgl(.x, .f, ...)

map_chr(.x, .f, ...)

map_int(.x, .f, ...)

map_dbl(.x, .f, ...)

map_raw(.x, .f, ...)

map_vec(.x, .f, ..., .ptype = NULL)

map_dfr(.x, .f, ..., .id = NULL)

map_dfc(.x, .f, ...)

walk(.x, .f, ...)

map_depth(.x, .depth, .f, ..., .ragged = FALSE)
}
\arguments{
\item{.x}{A list or atomic vector.}

\item{.f}{A function, formula, or vector (not necessarily atomic).

If a \strong{function}, it is used as is.

If a \strong{formula}, e.g. \code{~ .x + 2}, it is converted to a function. There
are three ways to refer to the arguments:
\itemize{
\item For a single argument function, use \code{.}
\item For a two argument function, use \code{.x} and \code{.y}
\item For more arguments, use \code{..1}, \code{..2}, \code{..3} etc
}

This syntax allows you to create very compact anonymous functions.

If \strong{character vector}, \strong{numeric vector}, or \strong{list}, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of \code{.default} will be returned.}

\item{...}{Additional arguments passed on to the mapped function.}

\item{.p}{A single predicate function, a formula describing such a
predicate function, or a logical vector of the same length as \code{.x}.
Alternatively, if the elements of \code{.x} are themselves lists of
objects, a string indicating the name of a logical element in the
inner lists. Only those elements where \code{.p} evaluates to
\code{TRUE} will be modified.}

\item{.else}{A function applied to elements of \code{.x} for which \code{.p}
returns \code{FALSE}.}

\item{.at}{A character vector of names, positive numeric vector of
positions to include, or a negative numeric vector of positions to
exlude. Only those elements corresponding to \code{.at} will be modified.
If the \code{tidyselect} package is installed, you can use \code{vars()} and
the \code{tidyselect} helpers to select elements.}

\item{.ptype}{If \code{NULL}, the default, the output type is determined by
computing the common type of the result elements. If no common type is
found, a list is returned.

Alternatively, you can supply \code{.ptype} to give the output a known type.
If \code{getOption("vctrs.no_guessing")} is \code{TRUE} you must supply this value:
this is a convenient way to make production code demand fixed types.}

\item{.id}{Either a string or \code{NULL}. If a string, the output will contain
a variable with that name, storing either the name (if \code{.x} is named) or
the index (if \code{.x} is unnamed) of the input. If \code{NULL}, the default, no
variable will be created.

Only applies to \code{_dfr} variant.}

\item{.depth}{Level of \code{.x} to map on. Use a negative value to count up
from the lowest level of the list.
\itemize{
\item \code{map_depth(x, 0, fun)} is equivalent to \code{fun(x)}.
\item \code{map_depth(x, 1, fun)} is equivalent to \code{x <- map(x, fun)}
\item \code{map_depth(x, 2, fun)} is equivalent to \code{x <- map(x, ~ map(., fun))}
}}

\item{.ragged}{If \code{TRUE}, will apply to leaves, even if they're not
at depth \code{.depth}. If \code{FALSE}, will throw an error if there are
no elements at depth \code{.depth}.}
}
\value{
All functions return a vector the same length as \code{.x}.

\code{map()} returns a list, \code{map_lgl()} a logical vector, \code{map_int()} an
integer vector, \code{map_dbl()} a double vector, and \code{map_chr()} a character
vector. \code{map_df()}, \code{map_dfc()}, \code{map_dfr()} all return a data frame.
The output of \code{.f} will be automatically typed upwards,
e.g. logical -> integer -> double -> character.

If \code{.x} has \code{names()}, the return value preserves those names.

\code{walk()} returns the input \code{.x} (invisibly). This makes it easy to
use in pipe.
}
\description{
The map functions transform their input by applying a function to
each element and returning a vector the same length as the input.
\itemize{
\item \code{map()}, \code{map_if()} and \code{map_at()} always return a list. See the
\code{\link[=modify]{modify()}} family for versions that return an object of the same
type as the input.

The \code{_if} and \code{_at} variants take a predicate function \code{.p} that
determines which elements of \code{.x} are transformed with \code{.f}.
\item \code{map_lgl()}, \code{map_int()}, \code{map_dbl()} and \code{map_chr()} each return
an atomic vector of the indicated type (or die trying).

The return value of \code{.f} must be of length one for each element of
\code{.x}. If \code{.f} uses an extractor function shortcut, \code{.default}
can be specified to handle values that are absent or empty.  See
\code{\link[=as_mapper]{as_mapper()}} for more on \code{.default}.
\item \code{map_vec()} attempts to compute the common type of the result
elements, and simplifies the result to the common type automatically
if one can be found. If no common type is found, a list is returned.
\item \code{map_dfr()} and \code{map_dfc()} return data frames created by
row-binding and column-binding respectively. They require dplyr
to be installed.
\item \code{walk()} calls \code{.f} for its side-effect and returns the input \code{.x}.
}
}
\examples{
1:10 \%>\%
  map(rnorm, n = 10) \%>\%
  map_dbl(mean)

# Or use an anonymous function
1:10 \%>\%
  map(function(x) rnorm(10, x))

# Or a formula
1:10 \%>\%
  map(~ rnorm(10, .x))

# The names of the input are preserved in the output:
list(foo = 1, bar = 2) \%>\% map(`+`, 10)

# Using set_names() with character vectors is handy to keep track
# of the original inputs:
set_names(c("foo", "bar")) \%>\% map_chr(paste0, ":suffix")

# Extract by name or position
# .default specifies value for elements that are missing or NULL
l1 <- list(list(a = 1L), list(a = NULL, b = 2L), list(b = 3L))
l1 \%>\% map("a", .default = "???")
l1 \%>\% map_int("b", .default = NA)
l1 \%>\% map_int(2, .default = NA)

# Supply multiple values to index deeply into a list
l2 <- list(
  list(num = 1:3,     letters[1:3]),
  list(num = 101:103, letters[4:6]),
  list()
)
l2 \%>\% map(c(2, 2))

# Use a list to build an extractor that mixes numeric indices and names,
# and .default to provide a default value if the element does not exist
l2 \%>\% map(list("num", 3))
l2 \%>\% map_int(list("num", 3), .default = NA)


# Use a predicate function to decide whether to map a function:
map_if(iris, is.factor, as.character)

# Specify an alternative with the `.else` argument:
map_if(iris, is.factor, as.character, .else = as.integer)

# A more realistic example: split a data frame into pieces, fit a
# model to each piece, summarise and extract R^2
mtcars \%>\%
  split(.$cyl) \%>\%
  map(~ lm(mpg ~ wt, data = .x)) \%>\%
  map(summary) \%>\%
  map_dbl("r.squared")

# Use map_lgl(), map_dbl(), etc to reduce to a vector.
# * list
mtcars \%>\% map(sum)
# * vector
mtcars \%>\% map_dbl(sum)

# If each element of the output is a data frame, use
# map_dfr to row-bind them together:
mtcars \%>\%
  split(.$cyl) \%>\%
  map(~ lm(mpg ~ wt, data = .x)) \%>\%
  map_dfr(~ as.data.frame(t(as.matrix(coef(.)))))
# (if you also want to preserve the variable names see
# the broom package)

# Use `map_depth()` to recursively traverse nested vectors and map
# a function at a certain depth:
x <- list(a = list(foo = 1:2, bar = 3:4), b = list(baz = 5:6))
str(x)
map_depth(x, 2, paste, collapse = "/")

# Equivalent to:
map(x, map, paste, collapse = "/")
}
\seealso{
Other map variants: \code{\link{imap}},
  \code{\link{invoke}}, \code{\link{lmap}},
  \code{\link{map2}}, \code{\link{modify}}
}
\concept{map variants}
