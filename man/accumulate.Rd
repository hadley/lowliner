% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/reduce.R
\name{accumulate}
\alias{accumulate}
\alias{accumulate2}
\title{Accumulate intermediate results of a vector reduction}
\usage{
accumulate(.x, .f, ..., .init, .dir = c("forward", "backward"))

accumulate2(.x, .y, .f, ..., .init)
}
\arguments{
\item{.x}{A list or atomic vector.}

\item{.f}{For \code{reduce()}, and \code{accumulate()}, a 2-argument
function. The function will be passed the accumulated value as
the first argument and the "next" value as the second argument.

For \code{reduce2()} and \code{accumulate2()}, a 3-argument function. The
function will be passed the accumulated value as the first
argument, the next value of \code{.x} as the second argument, and the
next value of \code{.y} as the third argument.

The reduction terminates early if \code{.f} returns a value wrapped in
a \code{\link[=done]{done()}}.}

\item{...}{Additional arguments passed on to the mapped function.}

\item{.init}{If supplied, will be used as the first value to start
the accumulation, rather than using \code{x[[1]]}. This is useful if
you want to ensure that \code{reduce} returns a correct value when \code{.x}
is empty. If missing, and \code{x} is empty, will throw an error.}

\item{.dir}{The direction of reduction as a string, one of
\code{"forward"} (the default) or \code{"backward"}. See the section about
direction below.}

\item{.y}{For \code{reduce2()} and \code{accumulate2()}, an additional
argument that is passed to \code{.f}. If \code{init} is not set, \code{.y}
should be 1 element shorter than \code{.x}.}
}
\value{
A vector the same length of \code{.x} with the same names as \code{.x}.

If \code{.init} is supplied, the length is extended by 1. If \code{.x} has
names, the initial value is given the name \code{".init"}, otherwise
the returned vector is kept unnamed.

If \code{.dir} is \code{"forward"} (the default), the first element is the
initial value (\code{.init} if supplied, or the first element of \code{.x})
and the last element is the final reduced value. In case of a
right accumulation, this order is reversed.

The accumulation terminates early if \code{.f} returns a value wrapped
in a \code{\link[=done]{done()}}. If the done box is empty, the last value is
used instead and the result is one element shorter (but always
includes the initial value, even when terminating at the first
iteration).
}
\description{
\code{accumulate()} \link[=reduce]{reduces} a vector with a binary function,
keeping all intermediate results, from the initial value to the
final reduced value, i.e. the result you'd have gotten if you used
\code{\link[=reduce]{reduce()}} instead of \code{accumulate()}.
}
\section{Life cycle}{


\code{accumulate_right()} is soft-deprecated in favour of the \code{.dir}
argument as of rlang 0.3.0. Note that the algorithm has
slightly changed: the accumulated value is passed to the right
rather than the left, which is consistent with a right reduction.
}

\examples{
# With an associative operation, the final value is always the
# same, no matter the direction. You'll find it in the last element
# for a left accumulation, and in the first element for a right one:
1:5 \%>\% accumulate(`+`)
1:5 \%>\% accumulate(`+`, .dir = "backward")

# The final value is always equal to the equivalent reduction:
1:5 \%>\% reduce(`+`)

# It is easier to understand the details of the reduction with
# `paste()`.
accumulate(letters[1:5], paste, sep = ".")

# Note how the intermediary reduced values are passed to the left
# with a left reduction, and to the right otherwise:
accumulate(letters[1:5], paste, sep = ".", .dir = "backward")

# `accumulate2()` is a version of `accumulate()` that works with
# ternary functions and one additional vector:
paste2 <- function(x, y, sep = ".") paste(x, y, sep = sep)
letters[1:4] \%>\% accumulate(paste2)
letters[1:4] \%>\% accumulate2(c("-", ".", "-"), paste2)


# You can shortcircuit an accumulation and terminate it early by
# returning a value wrapped in a done(). In the following example
# we return early if the result-so-far, which is passed on the LHS,
# meets a condition:
paste3 <- function(out, input, sep = ".") {
  if (nchar(out) > 4) {
    return(done(out))
  }
  paste(out, input, sep = sep)
}
letters \%>\% accumulate(paste3)

# Note how we get twice the same value in the accumulation. That's
# because we have returned it twice. To prevent this, return an empty
# done box to signal to accumulate() that it should terminate with the
# value of the last iteration:
paste3 <- function(out, input, sep = ".") {
  if (nchar(out) > 4) {
    return(done())
  }
  paste(out, input, sep = sep)
}
letters \%>\% accumulate(paste3)

# Here the early return branch checks the incoming inputs passed on
# the RHS:
paste4 <- function(out, input, sep = ".") {
  if (input == "f") {
    return(done())
  }
  paste(out, input, sep = sep)
}
letters \%>\% accumulate(paste4)


# Simulating stochastic processes with drift
\dontrun{
library(dplyr)
library(ggplot2)

rerun(5, rnorm(100)) \%>\%
  set_names(paste0("sim", 1:5)) \%>\%
  map(~ accumulate(., ~ .05 + .x + .y)) \%>\%
  map_dfr(~ data_frame(value = .x, step = 1:100), .id = "simulation") \%>\%
  ggplot(aes(x = step, y = value)) +
    geom_line(aes(color = simulation)) +
    ggtitle("Simulations of a random walk with drift")
}
}
\seealso{
\code{\link[=reduce]{reduce()}} when you only need the final reduced value.
}
